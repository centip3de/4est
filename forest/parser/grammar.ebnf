@@grammar::Forest
@@nameguard :: False

start
    =
    {statement}+
    ;

statement
    =
    | push_stmt
    | numeric_stmt
    | if_stmt
    | print_stmt
    | equality_stmt
    | input_stmt
    | length_stmt
    | iterate_stmt
    | range_stmt
    ;

iterate_stmt
    =
    'I' (boolean | pop_stmt | equality_stmt | number | length_stmt | string | array | range_stmt) {statement}+ 'E'
    ;

range_stmt
    =
    'R' (number | length_stmt)
    ;

print_stmt
    =
    '.' (push_term | pop_stmt)
    ;

input_stmt
    =
    ','
    ;

push_stmt
    =
    'P' push_term
    ;

push_term
    =
    | string
    | number
    | boolean
    | array
    | equality_stmt
    | input_stmt
    | numeric_stmt
    | length_stmt
    ;

numeric_stmt
    =
    | add_op
    | sub_op
    | div_op
    | exp_op
    | mul_op
    | mod_op
    ;

pop_stmt
    =
    'O'
    ;

if_stmt
    =
    if_term
    else_term
    ;

if_term
    =
    '?' (boolean | equality_stmt) {statement}+
    ;

else_term
    =
    '#' {statement}+
    ;

equality_stmt
    =
    | string '=' string
    | pop_stmt '=' string
    | input_stmt '=' string
    | number num_eq_term number
    | pop_stmt num_eq_term number
    | input_stmt num_eq_term number
    | length_stmt num_eq_term number
    | array '=' array
    | pop_stmt '=' array
    | boolean '=' boolean
    ;

length_stmt
    =
    'L' ( array | string | input_stmt)
    ;

num_eq_term
    =
    ('=' | '>' | '<')
    ;

add_op
    =
    number '+' number
    ;

sub_op
    =
    number '-' number
    ;

div_op
    =
    number '/' number
    ;

mul_op
    =
    number '*' number
    ;

mod_op
    =
    number '%' number
    ;

exp_op
    =
    number '^' number
    ;

array
    =
    '[' {array_term}+
    ;

array_term
    =
    (number | string) ';'
    ;

boolean
    =
    true | false
    ;

true
    =
    'T'
    ;

false
    =
    'F'
    ;

string
    =
    '"' letter_with_space '"'
    ;

letter_with_space
    =
    /[a-zA-Z ]+/
    ;

number
    =
    /\d+/
    ;
